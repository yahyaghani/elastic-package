---
description: ProjectDiscovery Cloud vulnerability changelogs â†’ ECS
processors:
  # Base event typing
  - set: { field: event.kind, value: event }
  - set: { field: event.category, value: ["vulnerability"] }
  - set: { field: event.type, value: ["change"] }
  - set: { field: event.module, value: "projectdiscovery_cloud" }
  - set: { field: event.dataset, value: "projectdiscovery_cloud.vulnerability" }

  # Timestamp: prefer created_at, fallback event.timestamp
  - set:
      field: _tmp_created_at
      copy_from: created_at
      ignore_failure: true
  - set:
      field: _tmp_created_at
      copy_from: event.timestamp
      if: 'ctx._tmp_created_at == null'
      ignore_failure: true
  - date:
      field: _tmp_created_at
      target_field: "@timestamp"
      formats: ["ISO8601"]
      ignore_failure: true

  # Map ECS vulnerability
  - rename: { field: vuln_id, target_field: vulnerability.id, ignore_missing: true }
  - rename: { field: vuln_status, target_field: vulnerability.status, ignore_missing: true }
  - rename: { field: event.info.description, target_field: vulnerability.description, ignore_missing: true }
  - rename: { field: event.info.reference, target_field: vulnerability.reference, ignore_missing: true }
  - rename: { field: event.info.severity, target_field: vulnerability.severity, ignore_missing: true }
  - set:    { field: vulnerability.scanner.vendor, value: "ProjectDiscovery" }
  - set:    { field: vulnerability.scanner.type, value: "nuclei" }
  - lowercase: { field: vulnerability.severity, ignore_missing: true }

  # Rule-ish details (template)
  - rename: { field: event.template-id, target_field: rule.id, ignore_missing: true }
  - rename: { field: event.info.name, target_field: rule.name, ignore_missing: true }
  - rename: { field: template_url, target_field: rule.reference, ignore_missing: true }

  # Target/asset (treat as provider resource)
  - rename: { field: event.host, target_field: host.hostname, ignore_missing: true }
  - rename: { field: event.ip, target_field: host.ip, ignore_missing: true }
  - rename: { field: target, target_field: server.address, ignore_missing: true }
  - convert: { field: event.port, type: long, target_field: server.port, ignore_missing: true }

  # Tags
  - rename: { field: event.info.tags, target_field: tags, ignore_missing: true }
  - append: { field: tags, value: "projectdiscovery" }
  - append: { field: tags, value: "easm" }

  # Preserve PD fields under custom namespace
  - set: { field: projectdiscovery.vulnerability.vuln_hash, value: "{{vuln_hash}}", ignore_empty_value: true }
  - set: { field: projectdiscovery.vulnerability.matcher_status, value: "{{matcher_status}}", ignore_empty_value: true }
  - set: { field: projectdiscovery.vulnerability.result_type, value: "{{result_type}}", ignore_empty_value: true }
  - set: { field: projectdiscovery.vulnerability.scan_id, value: "{{scan_id}}", ignore_empty_value: true }
  - set: { field: projectdiscovery.vulnerability.change_event, value: "{{change_event}}", ignore_empty_value: true }

  # Parse SSL response JSON safely (NO Groovy)
  - json:
      if: ctx.event != null && ctx.event.response != null && ctx.event.response instanceof String && ctx.event.response.startsWith("{")
      field: event.response
      target_field: _pd_tls
      add_to_root: false
      ignore_failure: true

  # Map a few TLS/X.509 fields (best-effort)
  - set: { field: tls.version, copy_from: _pd_tls.tls_version, ignore_empty_value: true }
  - set: { field: tls.cipher,  copy_from: _pd_tls.cipher,      ignore_empty_value: true }
  - set: { field: x509.not_before, copy_from: _pd_tls.not_before, ignore_empty_value: true }
  - set: { field: x509.not_after,  copy_from: _pd_tls.not_after,  ignore_empty_value: true }
  - set: { field: x509.subject.common_name, copy_from: _pd_tls.subject_cn, ignore_empty_value: true }
  - set: { field: x509.issuer.common_name,  copy_from: _pd_tls.issuer_cn,  ignore_empty_value: true }
  - set: { field: x509.fingerprint_sha256,  copy_from: _pd_tls.fingerprint_hash.sha256, ignore_empty_value: true }

  # Build related.* arrays without user-defined functions
  - script:
      lang: painless
      ignore_failure: true
      source: |
        // related.hosts: host.hostname
        if (ctx.host != null && ctx.host.hostname != null) {
          if (ctx.related == null) { ctx.related = new HashMap(); }
          if (ctx.related.hosts == null) { ctx.related.hosts = new ArrayList(); }
          if (!ctx.related.hosts.contains(ctx.host.hostname)) { ctx.related.hosts.add(ctx.host.hostname); }
        }
        // related.hosts: server.address
        if (ctx.server != null && ctx.server.address != null) {
          if (ctx.related == null) { ctx.related = new HashMap(); }
          if (ctx.related.hosts == null) { ctx.related.hosts = new ArrayList(); }
          if (!ctx.related.hosts.contains(ctx.server.address)) { ctx.related.hosts.add(ctx.server.address); }
        }
        // related.ip: host.ip
        if (ctx.host != null && ctx.host.ip != null) {
          if (ctx.related == null) { ctx.related = new HashMap(); }
          if (ctx.related.ip == null) { ctx.related.ip = new ArrayList(); }
          if (!ctx.related.ip.contains(ctx.host.ip)) { ctx.related.ip.add(ctx.host.ip); }
        }
        // related.hash: vuln_hash
        if (ctx.vuln_hash != null) {
          if (ctx.related == null) { ctx.related = new HashMap(); }
          if (ctx.related.hash == null) { ctx.related.hash = new ArrayList(); }
          if (!ctx.related.hash.contains(ctx.vuln_hash)) { ctx.related.hash.add(ctx.vuln_hash); }
        }

  # Cleanup
  - remove: { field: ["_tmp_created_at", "_pd_tls"], ignore_missing: true }

on_failure:
  - set: { field: error.message, value: "{{ _ingest.on_failure_message }}" }
